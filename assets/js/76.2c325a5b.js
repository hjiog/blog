(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{736:function(e,t,s){"use strict";s.r(t);var r=s(6),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"主流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主流程"}},[e._v("#")]),e._v(" 主流程")]),e._v(" "),s("p",[e._v("create ==> useStore")]),e._v(" "),s("p",[e._v("何时订阅？\n调用 useStore 时内部执行 useEffect 订阅\n若使用 useStore.getState().xx 则不会发生订阅")]),e._v(" "),s("p",[e._v("如何自定义订阅？\n调用 useStore.subscribe()。届时所有 setState 行为都会触发回调")]),e._v(" "),s("p",[e._v("如何基于state自定义订阅？\n调用 useStore.subscribe()，第二个参数传入 selector，若其他组件调用了 setState ，则会调用 selector 判断一下，若发生变化才会执行回调")]),e._v(" "),s("p",[e._v("为啥需要 subscribeWithSelector 中间件？\n原理是重写 subscribe 方法，使其支持传入 selector ，但是为何不内置？")]),e._v(" "),s("p",[e._v("why we should memoizing selectors ?")]),e._v(" "),s("p",[e._v("setState ==> dispatch")]),e._v(" "),s("p",[e._v("selector 作用？\nsetState 会调用所有listener, listen 函数中再执行 selector，有变化就会触发刷新")]),e._v(" "),s("p",[e._v("能否不传 selector ，自动按需更新？")]),e._v(" "),s("p",[e._v("为啥 ssr 需要 "),s("code",[e._v("Provider")])])])}),[],!1,null,null,null);t.default=o.exports}}]);